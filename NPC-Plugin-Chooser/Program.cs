using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using System.IO;
using NPCPluginChooser.Settings;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Noggog.Utility;
using Mutagen.Bethesda.Json;

namespace NPCPluginChooser
{
    public class Program
    {
        static Lazy<PatcherSettings> Settings = null!;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "NPC Appearance.esp")
                .Run(args);
        }

        private static void CanRunPatch(IRunnabilityState state)
        {
            PatcherSettings settings = Settings.Value;
            if (settings.AssetOutputDirectory != "" && !Directory.Exists(settings.AssetOutputDirectory))
            {
                throw new Exception("Cannot find output directory specified in settings: " + settings.AssetOutputDirectory);
            }

            if (settings.Mode != Mode.Simple && settings.MO2DataPath == "")
            {
                throw new Exception("MO2 Data Path must be set for any mode other than Simple.");
            }

            if (settings.MO2DataPath != "" && !Directory.Exists(settings.MO2DataPath))
            {
                throw new Exception("Cannot find the Mod Organizer 2 Mods folder specified in settings: " + settings.MO2DataPath);
            }
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            PatcherSettings settings = Settings.Value;

            PatcherSettings outputSettings = new PatcherSettings(); // only used if Mode == SettingsGen

            Dictionary<ModKey, string> PluginDirectoryDict = initPluginDirectoryDict(settings, state);

            getWarningsToSuppress(settings, state);
            getPathstoIgnore(settings, state);

            if (settings.AssetOutputDirectory != "" && Directory.Exists(settings.AssetOutputDirectory) && settings.ClearAssetOutputDirectory && settings.Mode != Mode.SettingsGen)
            {
                clearOuptutDir(settings);
            }

            if (settings.Mode == Mode.SettingsGen)
            {
                string settingsDirName = "NPC Settings";
                outputSettings.AssetOutputDirectory = settings.AssetOutputDirectory;
                outputSettings.ClearAssetOutputDirectory = settings.ClearAssetOutputDirectory;
                outputSettings.CopyExtraAssets = settings.CopyExtraAssets;
                outputSettings.MO2DataPath = settings.MO2DataPath;
                outputSettings.Mode = Mode.Deep;
                outputSettings.SuppressKnownMissingFileWarnings = settings.SuppressKnownMissingFileWarnings;

                int counter = 0;
                foreach (var npcCO in state.LoadOrder.PriorityOrder.Npc().WinningContextOverrides().ToList())
                {
                    if (generateSettingsForNPC(npcCO, settings, outputSettings, PluginDirectoryDict, state))
                    {
                        counter++;
                        if (counter % 100 == 0)
                        {
                            Console.WriteLine("Processed {0} humanoid NPCs", counter++);
                        }
                    }
                }

                outputSettings.PluginsToForward = sortPPS(outputSettings.PluginsToForward, state);
                flagPluginsForMerge(outputSettings.PluginsToForward, settings, state);

                // write output settings here

                var jsonSettings = new JsonSerializerSettings();
                jsonSettings.Converters.Add(new StringEnumConverter());
                jsonSettings.AddMutagenConverters();
                jsonSettings.ObjectCreationHandling = ObjectCreationHandling.Replace;
                jsonSettings.Formatting = Formatting.Indented;

                var outputPath = Path.Combine(settings.AssetOutputDirectory, settingsDirName, string.Format("settings_{0:yyyy-MM-dd_hh-mm-ss-tt}.json", DateTime.Now));
                try
                {
                    if (Directory.Exists(settings.AssetOutputDirectory) == false)
                    {
                        Directory.CreateDirectory(settings.AssetOutputDirectory);
                    }
                    if (Directory.Exists (Path.Combine(settings.AssetOutputDirectory, settingsDirName)) == false)
                    {
                        Directory.CreateDirectory(Path.Combine(settings.AssetOutputDirectory, settingsDirName));
                    }

                    string jsonStr = JsonConvert.SerializeObject(outputSettings, jsonSettings);
                    File.WriteAllText(outputPath, jsonStr);
                    Console.WriteLine("Wrote current settings to {0}. Use this file as a backup of your current settings by renaming it to \"settings.json\" and placing it into your Synthesis\\Data\\NPC-Plugin-Chooser folder.", outputPath);
                }
                catch
                {
                    throw new Exception("Could not write the generated settings object to " + outputPath);
                }
            }

            else
            {
                HashSet<mergeJsonOutputPluginEntry> mergeJSONlist = new HashSet<mergeJsonOutputPluginEntry>();
                
                foreach (var PPS in settings.PluginsToForward)
                {
                    Console.WriteLine("Processing {0}", PPS.Plugin.ToString());

                    if (PluginDirectoryDict.ContainsKey(PPS.Plugin) == false)
                    {
                        throw new Exception("Plugin -> Folder dictionary does not contain an entry for plugin " + PPS.Plugin.ToString());
                    }
                    string currentDataDir = PluginDirectoryDict[PPS.Plugin];

                    state.LoadOrder.TryGetValue(PPS.Plugin, out var currentModContext);
                    if (currentModContext != null && currentModContext.Mod != null)
                    {
                        foreach (var npc in currentModContext.Mod.Npcs)
                        {
                            if (PPS.SelectAll || (PPS.InvertSelection == false && PPS.NPCs.Contains(npc.AsLinkGetter())) || (PPS.InvertSelection == true && !PPS.NPCs.Contains(npc.AsLinkGetter())))
                            {
                                string NPCdispStr = npc.Name + " | " + npc.EditorID + " | " + npc.FormKey.ToString();
                                Console.WriteLine("Forwarding appearance of {0}", NPCdispStr);
                                if (faceGenExists(npc.FormKey, currentModContext.ModKey, currentDataDir, PPS.ExtraDataDirectories, settings.HandleBSAFiles_Patching, state, out var BSAfiles) == false)
                                {
                                    if (settings.AbortIfMissingFaceGen)
                                    {
                                        throw new Exception("Missing expected FaceGen for NPC " + NPCdispStr + " in folder " + currentDataDir + " (obtained based on plugin " + PPS.Plugin.ToString() + ")");
                                    }
                                    else
                                    {
                                        Console.WriteLine("WARNING: " + "Missing expected FaceGen for NPC " + NPCdispStr + " in folder " + currentDataDir + " (obtained based on plugin " + PPS.Plugin.ToString() + ")");
                                    }
                                }

                                var NPCoverride = addNPCtoPatch(npc, settings, state);
                                copyAssets(NPCoverride, currentModContext.ModKey, settings, currentDataDir, PPS, state);
                            }
                        }
                    }

                    //remap dependencies
                    if (!(settings.BaseGamePlugins.Contains(PPS.Plugin) || settings.PluginsExcludedFromMerge.Contains(PPS.Plugin)))
                    {
                        Console.WriteLine("Remapping Dependencies from {0}.", PPS.Plugin.ToString());
                        state.PatchMod.DuplicateFromOnlyReferenced(state.LinkCache, PPS.Plugin, out var _);
                    }

                    if (PPS.AddToMergeJSON && settings.BaseGamePlugins.Contains(PPS.Plugin) == false)
                    {
                        mergeJsonOutputPluginEntry j = new mergeJsonOutputPluginEntry();
                        j.filename = PPS.Plugin.ToString();
                        j.dataFolder = currentDataDir;
                        j.hash = CreateMD5(Path.Combine(currentDataDir, PPS.Plugin.ToString()));
                        mergeJSONlist.Add(j);
                    }
                }

                if (mergeJSONlist.Any())
                {
                    createJsonMergeFile(mergeJSONlist, settings, state);
                }
            }
        }      

        public static Npc addNPCtoPatch(INpcGetter userSelectedNPC, PatcherSettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            switch (settings.ForwardConflictWinnerData)
            {
                case false: return state.PatchMod.Npcs.GetOrAddAsOverride(userSelectedNPC);
                case true:
                    var allContexts = state.LinkCache.ResolveAllContexts<INpc, INpcGetter>(userSelectedNPC.FormKey)
                        .Take(2)
                        .ToList();
                    if (allContexts.Count < 2)
                    {
                        return state.PatchMod.Npcs.GetOrAddAsOverride(userSelectedNPC);
                    }
                    else
                    {
                        var winningOR = allContexts[^2].Record;
                        var forwardedOR = state.PatchMod.Npcs.GetOrAddAsOverride(winningOR);

                        if (!settings.ForwardConflictWinnerOutifts)
                        {
                            forwardedOR.DefaultOutfit.SetTo(userSelectedNPC.DefaultOutfit);
                        }

                        forwardedOR.FaceMorph = userSelectedNPC.FaceMorph?.DeepCopy();
                        
                        forwardedOR.FaceParts = userSelectedNPC.FaceParts?.DeepCopy();

                        forwardedOR.FarAwayModel.SetTo(userSelectedNPC.FarAwayModel);

                        forwardedOR.HairColor.SetTo(userSelectedNPC.HairColor);

                        forwardedOR.HeadParts.Clear();
                        forwardedOR.HeadParts.AddRange(userSelectedNPC.HeadParts);

                        forwardedOR.HeadTexture.SetTo(userSelectedNPC.HeadTexture);
                        
                        forwardedOR.Height = userSelectedNPC.Height;

                        forwardedOR.Race.SetTo(userSelectedNPC.Race);

                        if (!settings.ForwardConflictWinnerOutifts)
                        {
                            forwardedOR.SleepingOutfit.SetTo(userSelectedNPC.SleepingOutfit);
                        }

                        forwardedOR.TextureLighting = userSelectedNPC.TextureLighting;

                        forwardedOR.TintLayers.Clear();
                        forwardedOR.TintLayers.AddRange(userSelectedNPC.TintLayers.Select(a => a.DeepCopy()));
                        
                        forwardedOR.Weight = userSelectedNPC.Weight;

                        forwardedOR.WornArmor.SetTo(userSelectedNPC.WornArmor);

                        return forwardedOR;
                    }
            }
        }

        public static void clearOuptutDir(PatcherSettings settings)
        {
            string mPath = Path.Combine(settings.AssetOutputDirectory, "meshes");
            if (Directory.Exists(mPath))
            {
                DirectoryInfo diM = new DirectoryInfo(mPath);
                foreach (FileInfo file in diM.EnumerateFiles())
                {
                    file.Delete();
                }
                foreach (DirectoryInfo dir in diM.EnumerateDirectories())
                {
                    dir.Delete(true);
                }
            }

            string tPath = Path.Combine(settings.AssetOutputDirectory, "textures");
            if (Directory.Exists(tPath))
            {
                DirectoryInfo diM = new DirectoryInfo(tPath);
                foreach (FileInfo file in diM.EnumerateFiles())
                {
                    file.Delete();
                }
                foreach (DirectoryInfo dir in diM.EnumerateDirectories())
                {
                    dir.Delete(true);
                }
            }
        }
        public static bool generateSettingsForNPC(IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter> npcCO, PatcherSettings settings, PatcherSettings outputSettings, Dictionary<ModKey, string> PluginDirectoryDict, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var contexts = state.LinkCache.ResolveAllContexts<INpc, INpcGetter>(npcCO.Record.FormKey).ToList(); // [0] is winning override. [Last] is source plugin

            var FaceGenSubPaths = getFaceGenSubPathStrings(npcCO.Record.FormKey);

            var winningPlugin = new ModKey();

            var winnerFaceGenStreams = getFaceGenWinnerStreams(contexts, FaceGenSubPaths, PluginDirectoryDict, state, out bool hasFaceGen, out var winningBSAPlugin);
            if (hasFaceGen == false)
            {
                return false;
            }
            else if (winningBSAPlugin != null)
            {
                winningPlugin = winningBSAPlugin.Value;
            }

            if (settings.SettingsGenMode == SettingsGenMode.RecordConflictsOnly && !(contexts.Count > 1 && hasAppearanceRecordConflict(contexts.Last(), contexts.First())))
            {
                return false;
            }

            if (winningPlugin.IsNull) // if winning FaceGen is not from BSA (in which case its source mod was already found), figure out which mod the loose files came from
            {
                winningPlugin = getLooseFaceGenMatch(contexts, winnerFaceGenStreams, FaceGenSubPaths, PluginDirectoryDict, state);
            }

            winnerFaceGenStreams.Item1.Dispose();
            winnerFaceGenStreams.Item2.Dispose();

            // if a winning plugin was never found, warn user and continue
            if (winningPlugin.IsNull)
            {
                return false;
            }
            else
            {
                var currentPPS = new PerPluginSettings();
                bool foundCurrentPPS = false;
                foreach (var PPS in outputSettings.PluginsToForward)
                {
                    if (PPS.Plugin == winningPlugin)
                    {
                        currentPPS = PPS;
                        foundCurrentPPS = true;
                        break;
                    }
                }
                if (foundCurrentPPS == false)
                {
                    currentPPS.Plugin = winningPlugin;
                    currentPPS.InvertSelection = false;
                    outputSettings.PluginsToForward.Add(currentPPS);
                }

                currentPPS.NPCs.Add(npcCO.Record.AsLinkGetter());
            }

            return true;
        }

        public static bool hasAppearanceRecordConflict(IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter> conflictWinnner, IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter> baseNPC)
        {
            var cw = conflictWinnner.Record;
            var bn = baseNPC.Record;

            if ((cw.FaceMorph != null && bn.FaceMorph == null) || (cw.FaceMorph == null && bn.FaceMorph != null) || (cw.FaceMorph != null && !cw.FaceMorph.Equals(baseNPC.Record.FaceMorph))) { return true; }
            if ((cw.FaceParts != null && bn.FaceParts == null) || (cw.FaceParts == null && bn.FaceParts != null) || (cw.FaceParts != null && !cw.FaceParts.Equals(baseNPC.Record.FaceParts))) { return true; }
            if (!cw.FarAwayModel.Equals(bn.FarAwayModel)) { return true; }
            if (!cw.HairColor.Equals(bn.HairColor)) { return true; }
            if (!cw.HeadParts.Equals(bn.HeadParts)) { return true; }
            if (!cw.HeadTexture.Equals(bn.HeadTexture)) { return true; }
            if (!cw.Race.Equals(bn.Race)) { return true; }
            if (!cw.TextureLighting.Equals(bn.TextureLighting)) { return true; }
            if (!cw.TintLayers.Equals(bn.TintLayers)) { return true; }
            if (!cw.WornArmor.Equals(bn.WornArmor)) { return true; }

            return false;
        }

        public static bool faceGenExists(FormKey NPCFormKey, ModKey currentModKey, string rootPath, HashSet<string> extraDataPaths, bool handleBSAFiles, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, out (IArchiveFile?, IArchiveFile?) BSAFiles)
        {
            var FaceGenSubPaths = getFaceGenSubPathStrings(NPCFormKey);

            var BSAreaders = new HashSet<IArchiveReader>();
            if (handleBSAFiles)
            {
                BSAreaders = BSAHandler.openBSAArchiveReaders(rootPath, currentModKey);
            }
            BSAFiles = (null, null);

            // check for nif
            bool bNifExists = false;
            string FaceGenNifSubPath = Path.Combine(rootPath, "meshes", FaceGenSubPaths.Item1);
            if (File.Exists(FaceGenNifSubPath))
            {
                bNifExists = true;
            }
            else
            {
                if (handleBSAFiles && BSAreaders.Any())
                {
                    foreach (var reader in BSAreaders)
                    {
                        if (BSAHandler.TryGetFile(Path.Combine("meshes", FaceGenSubPaths.Item1), reader, out var nifFile))
                        {
                            bNifExists = true;
                            BSAFiles.Item1 = nifFile;
                            break;
                        }
                    }
                }

                if (bNifExists == false)
                {
                    foreach (string path in extraDataPaths)
                    {
                        if (File.Exists(FaceGenNifSubPath))
                        {
                            bNifExists = true;
                            break;
                        }
                    }
                }
            }

            if (bNifExists == false)
            {
                return false;
            }

            // check for Dds
            bool bDdsExists = false;
            string FaceGenDdsSubPath = Path.Combine(rootPath, "textures", FaceGenSubPaths.Item2);
            if (File.Exists(FaceGenDdsSubPath))
            {
                bDdsExists = true;
            }
            else
            {
                if (handleBSAFiles && BSAreaders.Any())
                {
                    foreach (var reader in BSAreaders)
                    {
                        if (BSAHandler.TryGetFile(Path.Combine("textures", FaceGenSubPaths.Item2), reader, out var DdsFile))
                        {
                            bDdsExists = true;
                            BSAFiles.Item2 = DdsFile;
                            break;
                        }
                    }
                }

                if (bDdsExists == false)
                {
                    foreach (string path in extraDataPaths)
                    {
                        if (File.Exists(FaceGenDdsSubPath))
                        {
                            bDdsExists = true;
                            break;
                        }
                    }
                }
            }

            if (bDdsExists == false)
            {
                return false;
            }


            return true;
        }

        public static (MemoryStream, MemoryStream) getFaceGenWinnerStreams(List<IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter>> allNPCcontexts, (string, string) FaceGenSubPaths, Dictionary<ModKey, string> PluginDirectoryDict, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, out bool success, out ModKey? BSAwinner)
        {
            success = true;
            BSAwinner = null; // if the winning FaceGen is in a BSA, no need for the calling function to waste time looking for it - just report the calling ModKey here

            ModKey NifBSAWinner = new ModKey();
            ModKey DdsBSAWinner = new ModKey();

            MemoryStream NifStream = new MemoryStream();
            MemoryStream DdsStream = new MemoryStream();

            // check for loose file in data path first.

            string winnerMeshPath = Path.Combine(state.DataFolderPath, "meshes", FaceGenSubPaths.Item1);
            string winnerTexPath = Path.Combine(state.DataFolderPath, "textures", FaceGenSubPaths.Item2);

            bool meshFound = false;
            bool texFound = false;

            if (File.Exists(winnerMeshPath))
            {
                using (var mFile = File.OpenRead(winnerMeshPath))
                {
                    mFile.CopyTo(NifStream);
                    meshFound = true;
                }
            }

            if (File.Exists(winnerTexPath))
            {
                using (var tFile = File.OpenRead(winnerTexPath))
                {
                    tFile.CopyTo(DdsStream);
                    texFound = true;
                }
            }

            // if files aren't loose, try in bsa
            if (meshFound == false || texFound == false)
            {
                string BSAmeshPath = Path.Combine("meshes", FaceGenSubPaths.Item1);
                string BSAtexPath = Path.Combine("textures", FaceGenSubPaths.Item2);
                foreach (var context in allNPCcontexts) // winning context is first, root is last
                {
                    if (state.LinkCache.TryResolve<IRaceGetter>(context.Record.Race.FormKey, out var currentRaceGetter) && !currentRaceGetter.Flags.HasFlag(Race.Flag.FaceGenHead))
                    {
                        continue;
                    }

                    var currentContextReaders = BSAHandler.openBSAArchiveReaders(PluginDirectoryDict[context.ModKey], context.ModKey);

                    if (meshFound == false && BSAHandler.HaveFile(BSAmeshPath, currentContextReaders, out var archiveMeshFile) && archiveMeshFile != null)
                    {
                        archiveMeshFile.CopyDataTo(NifStream);
                        meshFound = true;
                        NifBSAWinner = context.ModKey;
                    }

                    if (texFound == false && BSAHandler.HaveFile(BSAtexPath, currentContextReaders, out var archiveTexFile) && archiveTexFile != null)
                    {
                        archiveTexFile.CopyDataTo(DdsStream);
                        texFound = true;
                        DdsBSAWinner = context.ModKey;
                    }

                    if (meshFound && texFound) 
                    {
                        if (!(NifBSAWinner.IsNull && DdsBSAWinner.IsNull) && NifBSAWinner != DdsBSAWinner)
                        {
                            Console.WriteLine("The winning FaceGen nif and the winning FaceGen dds belonged to BSA archives for different plugins. This is unsupported.");
                            Console.WriteLine("NPC: {0}", context.Record.Name);
                            Console.WriteLine("Winning NIF mod: {0}", NifBSAWinner.ToString());
                            Console.WriteLine("Winning DDS mod: {0}", DdsBSAWinner.ToString());
                            success = false;
                            return (NifStream, DdsStream);
                        }
                        else
                        {
                            BSAwinner = NifBSAWinner;
                        }
                        break; 
                    }
                }
            }

            if (meshFound == false || texFound == false)
            {
                success = false;
            }

            return (NifStream, DdsStream);
        }

        public static ModKey getLooseFaceGenMatch(List<IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter>> allNPCcontexts, (MemoryStream, MemoryStream) winnerStreams, (string, string) FaceGenSubPaths, Dictionary<ModKey, string> PluginDirectoryDict, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            ModKey winner = new ModKey();

            MemoryStream currentMeshStream = new MemoryStream();
            MemoryStream currentTexStream = new MemoryStream();

            foreach (var context in allNPCcontexts) // winning context is first, root is last
            {
                bool meshMatched = false;
                bool texMatched = false;

                string modMeshPath = Path.Combine(PluginDirectoryDict[context.ModKey], "meshes", FaceGenSubPaths.Item1);
                string modTexPath = Path.Combine(PluginDirectoryDict[context.ModKey], "textures", FaceGenSubPaths.Item2);

                if (File.Exists(modMeshPath))
                {
                    using (var mFile = File.OpenRead(modMeshPath))
                    {
                        mFile.CopyTo(currentMeshStream);
                        if (CompareMemoryStreams(currentMeshStream, winnerStreams.Item1))
                        {
                            meshMatched = true;
                        }
                    }
                }

                if (File.Exists(modTexPath))
                {
                    using (var tFile = File.OpenRead(modTexPath))
                    {
                        tFile.CopyTo(currentTexStream);
                        if (CompareMemoryStreams(currentTexStream, winnerStreams.Item2))
                        {
                            texMatched = true;
                        }
                    }
                }

                if (meshMatched && texMatched)
                {
                    winner = context.ModKey;
                    break;
                }
            }

            currentMeshStream.Dispose();
            currentTexStream.Dispose();

            return winner;
        }

        //https://stackoverflow.com/questions/2978727/most-efficient-way-to-compare-a-memorystream-to-a-file-c-sharp-net/9346745
        public static bool CompareMemoryStreams(MemoryStream ms1, MemoryStream ms2)
        {
            if (ms1.Length != ms2.Length)
                return false;
            ms1.Position = 0;
            ms2.Position = 0;

            var msArray1 = ms1.ToArray();
            var msArray2 = ms2.ToArray();

            return msArray1.SequenceEqual(msArray2);
        }

        /*
        public static bool checkFaceGenMatch(IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter> currentNPCcontext, IEnumerable<IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter>> allNPCcontexts, string currentModDir, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var FaceGenSubPaths = getFaceGenSubPathStrings(currentNPCcontext.Record.FormKey);

            string modMeshPath = Path.Combine(currentModDir, "meshes", FaceGenSubPaths.Item1);

            MemoryStream currentStream = new MemoryStream();
            FileStream winnerStream;

            HashSet<IArchiveReader> readers_currentMod = new HashSet<IArchiveReader>();

            readers_currentMod = BSAHandler.openBSAArchiveReaders(currentModDir, currentNPCcontext.ModKey);

            // get current mod mesh
            if (File.Exists(modMeshPath))
            {
                var mFile = File.Open(modMeshPath, FileMode.Open);
                mFile.CopyTo(currentStream);
            }
            else if (BSAHandler.HaveFile(modMeshPath, readers_currentMod, out var archiveMeshFile) && archiveMeshFile != null)
            {
                archiveMeshFile.CopyDataTo(currentStream);
            }
            else
            {
                return false;
            }


            string winnerMeshPath = Path.Combine(state.DataFolderPath, "meshes", FaceGenSubPaths.Item1); 


            if (FileComparison.FilesAreEqual(modMeshPath, winnerMeshPath) == false) 
            {
                return false;
            }

            string modTexPath = Path.Combine(currentModDir, "textures", FaceGenSubPaths.Item2); 
            
            if (File.Exists(modTexPath) == false && BSAHandler.HaveFile(modTexPath, readers_currentMod, out var archiveTexFile) == false) // If the given override doesn't provide facegen, then it trivially is not the facegen conflict winner
            {
                return false;
            }

            string winnerTexPath = Path.Combine(state.DataFolderPath, "textures", FaceGenSubPaths.Item2);

            if (FileComparison.FilesAreEqual(modTexPath, winnerTexPath) == false)
            {
                return false;
            }

            return true;
        }
        */


        public static void getWarningsToSuppress(PatcherSettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            string settingsPath = Path.Combine(state.ExtraSettingsDataPath, "Warnings To Suppress.json");
            if (!File.Exists(settingsPath))
            {
                throw new Exception("Could not find the list of known missing files (expected at: " + settingsPath + ").");
            }

            try
            {
                string file = File.ReadAllText(settingsPath);
                var tmp = JsonConvert.DeserializeObject<List<suppressedWarnings>>(file);

                if (tmp == null)
                {
                    throw new Exception("Could not deserialize the list of suppressed file warnings at " + settingsPath + ". Please make sure you don't have an old version, and that you introduced JSON format errors if you edited it yourself.");
                }

                foreach (var sw in tmp)
                {
                    var updated = new suppressedWarnings();
                    updated.Plugin = sw.Plugin;
                    foreach (string s in sw.Paths)
                    {
                        updated.Paths.Add(s.ToString().Replace(@"\\", @"\"));
                    }
                    settings.warningsToSuppress.Add(updated);

                    if (updated.Plugin.ToLower() == "global")
                    {
                        settings.warningsToSuppress_Global = updated;
                    }
                }
            }
            catch
            {
                throw new Exception("Failed to deserialize the list of suppressed file warnings at " + settingsPath + ". Please make sure you don't have an old version, and that you introduced JSON format errors if you edited it yourself.");
            }
        }

        public static void getPathstoIgnore(PatcherSettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            string settingsPath = Path.Combine(state.ExtraSettingsDataPath, "Paths To Ignore.json");
            if (!File.Exists(settingsPath))
            {
                throw new Exception("Could not find the list of asset paths to ignore (expected at: " + settingsPath + ").");
            }

            try
            {
                var tempJArray = JArray.Parse(File.ReadAllText(settingsPath));
                foreach (var s in tempJArray)
                {
                    settings.pathsToIgnore.Add(s.ToString().Replace(@"\\", @"\"));
                }
            }
            catch
            {
                throw new Exception("Could not parse the list of asset paths to ignore (expected at: " + settingsPath + ").");
            }
        }

        public static Dictionary<ModKey, string> initPluginDirectoryDict(PatcherSettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Dictionary<ModKey, string> PluginDirectoryDict = new Dictionary<ModKey, string>();
            if (settings.MO2DataPath == null || settings.MO2DataPath.Length == 0)
            {
                return PluginDirectoryDict;
            }

            if (settings.Mode == Mode.SettingsGen)
            {
                foreach (var mkPair in state.LoadOrder)
                {
                    var mk = mkPair.Key;

                    if (settings.BaseGamePlugins.Contains(mk)) 
                    {
                        PluginDirectoryDict.Add(mk, state.DataFolderPath);
                        continue; 
                    }

                    bool dirFound = false;
                    foreach (var dirName in Directory.GetDirectories(settings.MO2DataPath))
                    {
                        string potentialPath = Path.Join(dirName, mk.ToString());
                        if (File.Exists(potentialPath))
                        {
                            PluginDirectoryDict.Add(mk, dirName);
                            dirFound = true;
                            break;
                        }
                    }
                    if (dirFound == false)
                    {
                        Console.WriteLine("Could not find a mod folder for plugin {0}. Assuming this plugin is in the Overwrite folder and is not an appearance-related plugin.", mk.ToString());
                    }
                }
            }
            else
            {
                foreach (var PPS in settings.PluginsToForward)
                {
                    if (PPS.Plugin != null)
                    {
                        switch (settings.Mode)
                        {
                            case Mode.Deep:
                                // forced directory overrides even baseDataFolder
                                if (PPS.ForcedAssetDirectory != "")
                                {
                                    if (Directory.Exists(PPS.ForcedAssetDirectory) == false)
                                    {
                                        throw new Exception("Could not find forced asset directory for plugin " + PPS.Plugin.ToString() + " at " + PPS.ForcedAssetDirectory);
                                    }
                                    PluginDirectoryDict.Add(PPS.Plugin, PPS.ForcedAssetDirectory);
                                    break;
                                }
                                if (settings.BaseGamePlugins.Contains(PPS.Plugin))
                                {
                                    PluginDirectoryDict.Add(PPS.Plugin, state.DataFolderPath);
                                    break;
                                }

                                bool dirFound = false;
                                foreach (var dirName in Directory.GetDirectories(settings.MO2DataPath))
                                {
                                    string potentialPath = Path.Join(dirName, PPS.Plugin.ToString());
                                    if (File.Exists(potentialPath))
                                    {
                                        PluginDirectoryDict.Add(PPS.Plugin, dirName);
                                        dirFound = true;
                                        break;
                                    }
                                }
                                if (dirFound == false)
                                {
                                    throw new Exception("Cannot find any folder within " + settings.MO2DataPath + " that contains plugin " + PPS.Plugin.ToString());
                                }
                                break;

                            case Mode.Simple:
                                PluginDirectoryDict.Add(PPS.Plugin, state.DataFolderPath);
                                break;
                        }
                    }
                }
            }
            return PluginDirectoryDict;
        }

        public static void copyAssets(Npc npc, ModKey NPCModKey, PatcherSettings settings, string currentModDirectory, PerPluginSettings PPS, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            HashSet<string> meshes = new HashSet<string>();
            HashSet<string> textures = new HashSet<string>();

            //FaceGen
            var FaceGenSubPaths = getFaceGenSubPathStrings(npc.FormKey);
            meshes.Add(FaceGenSubPaths.Item1);
            textures.Add(FaceGenSubPaths.Item2);

            if (settings.CopyExtraAssets)
            {
                getAssetsReferencedByplugin(npc, settings, meshes, textures, state);
            }

            //extract needed files from BSA
            HashSet<string> extractedMeshFiles = new HashSet<string>();
            HashSet<string> extractedTexFiles = new HashSet<string>();
            if (settings.HandleBSAFiles_Patching) // if settings.CopyExtraAssets is disabled, then only FaceGen will be extracted here (if in BSA)
            {
                unpackAssetsFromBSA(meshes, textures, extractedMeshFiles, extractedTexFiles, NPCModKey, currentModDirectory, settings); // meshes and textures are edited in this function - found & extracted files are removed from the HashSets. Only loose files remain
            } // end BSA handling for extra assets found in plugin


            if (settings.CopyExtraAssets && PPS.FindExtraTexturesInNifs)
            {
                HashSet<string> alreadyHandledTextures = new HashSet<string>(textures, StringComparer.OrdinalIgnoreCase); // ignored these if found in nif because they have already been processed
                alreadyHandledTextures.UnionWith(extractedTexFiles); // will simply be empty if settings.HandleBSAFiles_Patching == false

                HashSet<string> extraTexturesFromNif = new HashSet<string>();
                getExtraTexturesFromNif(meshes, currentModDirectory, extraTexturesFromNif, alreadyHandledTextures); //traverse nifs for extra textures (loose nifs - in mod folder)

                if (settings.HandleBSAFiles_Patching)
                {
                    getExtraTexturesFromNif(extractedMeshFiles, settings.AssetOutputDirectory, extraTexturesFromNif, alreadyHandledTextures); //traverse nifs for extra textures (BSA extracted nifs - in output folder)
                    
                    // extract these additional textures from BSA if possible
                    HashSet<string> ExtractedExtraTextures = new HashSet<string>();
                    unpackAssetsFromBSA(new HashSet<string>(), extraTexturesFromNif, new HashSet<string>(), ExtractedExtraTextures, NPCModKey, currentModDirectory, settings); // if any additional textures live the BSA, unpack them
                    
                    // remove BSA-unpacked textures from the additional texture list
                    foreach (string s in ExtractedExtraTextures)
                    {
                        extraTexturesFromNif.Remove(s);
                    }
                }
                // copy extra texture list to output texture list
                foreach (string s in extraTexturesFromNif)
                {
                    textures.Add(s);
                }

            }

            // copy loose files
            var warningsToSuppressList = settings.warningsToSuppress.Where(w => w.Plugin.Equals(PPS.Plugin.ToString(), StringComparison.OrdinalIgnoreCase));
            var warningsToSuppress = new HashSet<string>(settings.warningsToSuppress_Global.Paths);
            if (warningsToSuppressList.Any()) { warningsToSuppress = warningsToSuppressList.First().Paths; }

            copyAssetFiles(settings, currentModDirectory, meshes, PPS.ExtraDataDirectories, "Meshes", warningsToSuppress, state.DataFolderPath);
            copyAssetFiles(settings, currentModDirectory, textures, PPS.ExtraDataDirectories, "Textures", warningsToSuppress, state.DataFolderPath);
        }

        public static void getExtraTexturesFromNif(HashSet<string> NifPaths, string NifDirectory, HashSet<string> outputTextures, HashSet<string> ignoredTextures)
        {
            foreach (var nifpath in NifPaths)
            {
                string fullPath = Path.Combine(NifDirectory, "meshes", nifpath);
                if (Path.GetExtension(nifpath) == ".nif" && File.Exists(fullPath))
                {
                    var nifTextures = NifHandler.getExtraTexturesFromNif(fullPath);
                    foreach (var t in nifTextures)
                    {
                        if (outputTextures.Contains(t) == false && ignoredTextures.Contains(t) == false)
                        {
                            outputTextures.Add(t);
                        }
                    }
                }
            }
        }

        public static void unpackAssetsFromBSA(HashSet<string> MeshesToExtract, HashSet<string> TexturesToExtract, HashSet<string> extractedMeshes, HashSet<string> ExtractedTextures, ModKey currentModKey, string currentModDirectory, PatcherSettings settings)
        {
            var BSAreaders = BSAHandler.openBSAArchiveReaders(currentModDirectory, currentModKey);
            foreach (string subPath in MeshesToExtract)
            {
                string meshPath = Path.Combine("meshes", subPath);
                foreach (var reader in BSAreaders)
                {
                    if (BSAHandler.TryGetFile(meshPath, reader, out var file) && file != null)
                    {
                        extractedMeshes.Add(subPath);
                        string destFile = Path.Combine(settings.AssetOutputDirectory, meshPath);
                        BSAHandler.extractFileFromBSA(file, destFile);
                        break;
                    }
                }
            }

            foreach (string subPath in TexturesToExtract)
            {
                string texPath = Path.Combine("textures", subPath);
                foreach (var reader in BSAreaders)
                {
                    if (BSAHandler.TryGetFile(texPath, reader, out var file) && file != null)
                    {
                        ExtractedTextures.Add(subPath);
                        string destFile = Path.Combine(settings.AssetOutputDirectory, texPath);
                        BSAHandler.extractFileFromBSA(file, destFile);
                        break;
                    }
                }
            }

            // remove extracted files from list, which should now only contain loose files
            foreach (string s in extractedMeshes)
            {
                MeshesToExtract.Remove(s);
            }
            foreach (String s in ExtractedTextures)
            {
                TexturesToExtract.Remove(s);
            }
        }

        public static void getAssetsReferencedByplugin(Npc npc, PatcherSettings settings, HashSet<string> meshes, HashSet<string> textures, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            //headparts
            foreach (var hp in npc.HeadParts)
            {
                if (!settings.PluginsExcludedFromMerge.Contains(hp.FormKey.ModKey))
                {
                    getHeadPartAssetPaths(hp, textures, meshes, settings.PluginsExcludedFromMerge, state);
                }
            }

            // armor and armature
            if (npc.WornArmor != null && state.LinkCache.TryResolve<IArmorGetter>(npc.WornArmor.FormKey, out var wnamGetter) && wnamGetter.Armature != null)
            {
                foreach (var aa in wnamGetter.Armature)
                {
                    if (!settings.PluginsExcludedFromMerge.Contains(aa.FormKey.ModKey))
                    {
                        {
                            getARMAAssetPaths(aa, textures, meshes, settings.PluginsExcludedFromMerge, state);
                        }
                    }
                }
            }
        }

        public static (string, string) getFaceGenSubPathStrings(FormKey npcFormKey)
        {
            string meshPath = "actors\\character\\facegendata\\facegeom\\" + npcFormKey.ModKey.ToString() + "\\00" + npcFormKey.IDString() + ".nif";
            string texPath = "actors\\character\\facegendata\\facetint\\" + npcFormKey.ModKey.ToString() + "\\00" + npcFormKey.IDString() + ".dds";
            return (meshPath, texPath);
        }

        public static void copyAssetFiles(PatcherSettings settings, string dataPath, HashSet<string> assetPathList, HashSet<string> ExtraDataDirectories, string type, HashSet<string> warningsToSuppress, string gameDataFolder)
        {
            string outputPrepend = Path.Combine(settings.AssetOutputDirectory, type);
            if (Directory.Exists(outputPrepend) == false)
            {
                Directory.CreateDirectory(outputPrepend);
            }

            foreach (string s in assetPathList)
            {
                if (!isIgnored(s, settings.pathsToIgnore))
                {
                    string currentPath = Path.Join(dataPath, type, s);
                    
                    bool bFileExists = false;
                    // check if file exists at primary path
                    if (File.Exists(currentPath))
                    {
                        bFileExists = true;
                    }
                    else
                    {
                        // check if file exists in the specified extra data paths
                        foreach (string extraDir in ExtraDataDirectories)
                        {
                            currentPath = Path.Join(extraDir, type, s);
                            if (File.Exists(currentPath))
                            {
                                bFileExists = true;
                                break;
                            }
                        }
                        if (bFileExists == false && settings.GetMissingExtraAssetsFromAvailableWinners && s.IndexOf("actors\\character\\facegendata\\facetint") != 0 && s.IndexOf("actors\\character\\facegendata\\facegeom") != 0) // if enabled & asset is not FaceGen, look for it in global data path.
                        {
                            currentPath = Path.Join(gameDataFolder, type, s);
                            if (File.Exists(currentPath))
                            {
                                bFileExists = true;
                            }
                        }
                    }

                    if (bFileExists == false)
                    {
                        bool suppressMeSpecifically = settings.SuppressKnownMissingFileWarnings && (warningsToSuppress.Any(s => s.Equals(s, StringComparison.OrdinalIgnoreCase)));
                        bool isTriFile = getExtensionOfMissingFile(s) == ".tri";
                        bool suppressThis = settings.SuppressAllMissingFileWarnings || suppressMeSpecifically || isTriFile;

                        if (!suppressThis) // nested if statement intentional; otherwise a suppressed warning goes into the else block despite the target file not existing
                        {
                            if (settings.AbortIfMissingExtraAssets)
                            {
                                if (ExtraDataDirectories.Count == 0)
                                {
                                    throw new Exception("Extra Asset " + currentPath + " was not found.");
                                }
                                else
                                {
                                    throw new Exception("Extra Asset " + s + " was not found in " + dataPath + " or any Extra Data Directories.");
                                }
                            }
                            else
                            {
                                if (ExtraDataDirectories.Count == 0)
                                {
                                    Console.WriteLine("Warning: Extra Asset " + currentPath + " was not found.");
                                }
                                else
                                {
                                    Console.WriteLine("Warning: Extra Asset " + s + " was not found in " + dataPath + " or any Extra Data Directories.");
                                }
                            }
                        }
                    }
                    else
                    {
                        string destPath = Path.Join(outputPrepend, s);

                        FileInfo fileInfo = new FileInfo(destPath);
                        if (fileInfo != null && fileInfo.Directory != null && !fileInfo.Directory.Exists)
                        {
                            Directory.CreateDirectory(fileInfo.Directory.FullName);
                        }

                        File.Copy(currentPath, destPath, true);
                    }
                }
            }
        }

        public static string getExtensionOfMissingFile(string input)
        {
            if (input == "") { return ""; }

            input = input.ToLower();
            var split = input.Split('.');
            return "." + split[split.Length - 1];
        }

        public static bool isIgnored (string s, HashSet<string> toIgnore)
        {
            string l = s.ToLower();
            foreach (string ig in toIgnore)
            {
                if (ig.ToLower() == l)
                {
                    return true;
                }
            }
            return false;
        }

        public static void getARMAAssetPaths(IFormLinkGetter<IArmorAddonGetter> aa, HashSet<string> texturePaths, HashSet<string> meshPaths, HashSet<ModKey> PluginsExcludedFromMerge, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (!state.LinkCache.TryResolve<IArmorAddonGetter>(aa.FormKey, out var aaGetter))
            {
                return;
            }

            if (aaGetter.WorldModel != null && aaGetter.WorldModel.Male != null && aaGetter.WorldModel.Male.File != null)
            {
                meshPaths.Add(aaGetter.WorldModel.Male.File);
            }
            if (aaGetter.WorldModel != null && aaGetter.WorldModel.Female != null && aaGetter.WorldModel.Female.File != null)
            {
                meshPaths.Add(aaGetter.WorldModel.Female.File);
            }

            if (aaGetter.SkinTexture != null && aaGetter.SkinTexture.Male != null && !PluginsExcludedFromMerge.Contains(aaGetter.SkinTexture.Male.FormKey.ModKey) && state.LinkCache.TryResolve<ITextureSetGetter>(aaGetter.SkinTexture.Male.FormKey, out var mSkinTxst))
            {
                getTextureSetPaths(mSkinTxst, texturePaths);
            }
            if (aaGetter.SkinTexture != null && aaGetter.SkinTexture.Female != null && !PluginsExcludedFromMerge.Contains(aaGetter.SkinTexture.Female.FormKey.ModKey) && state.LinkCache.TryResolve<ITextureSetGetter>(aaGetter.SkinTexture.Female.FormKey, out var fSkinTxst))
            {
                getTextureSetPaths(fSkinTxst, texturePaths);
            }
        }

        public static void getHeadPartAssetPaths(IFormLinkGetter<IHeadPartGetter> hp, HashSet<string> texturePaths, HashSet<string> meshPaths, HashSet<ModKey> PluginsExcludedFromMerge, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (!state.LinkCache.TryResolve<IHeadPartGetter>(hp.FormKey, out var hpGetter))
            {
                return;
            }

            if (hpGetter.Model != null && hpGetter.Model.File != null)
            {
                meshPaths.Add(hpGetter.Model.File);
            }

            if (hpGetter.Parts != null)
            {
                foreach (var part in hpGetter.Parts)
                {
                    if (part.FileName != null)
                    {
                        meshPaths.Add(part.FileName);
                    }
                }
            }

            if (hpGetter.TextureSet != null && state.LinkCache.TryResolve<ITextureSetGetter>(hpGetter.TextureSet.FormKey, out var hTxst))
            {
                getTextureSetPaths(hTxst, texturePaths);
            }

            if (hpGetter.ExtraParts != null)
            {
                foreach (var EP in hpGetter.ExtraParts)
                {
                    if (!PluginsExcludedFromMerge.Contains(EP.FormKey.ModKey))
                    {
                        getHeadPartAssetPaths(EP, texturePaths, meshPaths, PluginsExcludedFromMerge, state);
                    }
                }
            }
        }

        public static void getTextureSetPaths(ITextureSetGetter Txst, HashSet<string> texturePaths)
        {
            if (Txst.Diffuse != null)
            {
                texturePaths.Add(Txst.Diffuse);
            }
            if (Txst.NormalOrGloss != null)
            {
                texturePaths.Add(Txst.NormalOrGloss);
            }
            if (Txst.BacklightMaskOrSpecular != null)
            {
                texturePaths.Add(Txst.BacklightMaskOrSpecular);
            }
            if (Txst.Environment != null)
            {
                texturePaths.Add(Txst.Environment);
            }
            if (Txst.EnvironmentMaskOrSubsurfaceTint != null)
            {
                texturePaths.Add(Txst.EnvironmentMaskOrSubsurfaceTint);
            }
            if (Txst.GlowOrDetailMap != null)
            {
                texturePaths.Add(Txst.GlowOrDetailMap);
            }
        }

        public static HashSet<PerPluginSettings> sortPPS(HashSet<PerPluginSettings> inputPPS, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            HashSet<PerPluginSettings> outputPPS = new HashSet<PerPluginSettings>();

            foreach (var plugin in state.LoadOrder)
            {
                var matchedPPS = inputPPS.Where(p => p.Plugin == plugin.Key);
                if (matchedPPS.Any())
                {
                    outputPPS.Add(matchedPPS.First());
                    continue;
                }
            }

            return outputPPS;
        }

        public static void flagPluginsForMerge(HashSet<PerPluginSettings> inputPPS, PatcherSettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            foreach (var pps in inputPPS)
            {
                if (settings.BaseGamePlugins.Contains(pps.Plugin))
                {
                    continue;
                }

                bool hasNewNPC = false;
                var currentModIndex = state.LoadOrder.IndexOf(pps.Plugin);
                if (currentModIndex >= 0)
                {
                    var currentMod = state.LoadOrder[currentModIndex].Mod;
                    if (currentMod == null) { continue; }
                    
                    foreach (var npc in currentMod.Npcs)
                    {
                        if (npc.FormKey.ModKey == pps.Plugin)
                        {
                            hasNewNPC = true;
                            break;
                        }
                    }
                }
                if (hasNewNPC == false)
                {
                    pps.AddToMergeJSON = true;
                }
            }
        }

        //https://stackoverflow.com/questions/11454004/calculate-a-md5-hash-from-a-string
        public static string CreateMD5(string filename)
        {
            if (File.Exists(filename) == false)
            {
                Console.WriteLine("Could not open file to create hash: {0}", filename);
            }
            using (var md5 = System.Security.Cryptography.MD5.Create())
            {
                using (var stream = File.OpenRead(filename))
                {
                    var hash = md5.ComputeHash(stream);
                    if (hash == null)
                    {
                        Console.WriteLine("Could not compute hash of file {0}", filename);
                        return "";
                    }
                    else
                    {
                        return BitConverter.ToString(hash).Replace("-", string.Empty).ToLower(); // https://stackoverflow.com/questions/37106426/system-byte-is-being-returned-instead-of-the-actual-data
                    }
                }
            }
        }

        public static void createJsonMergeFile(HashSet<mergeJsonOutputPluginEntry> plugins, PatcherSettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            megeJsonOutput output = new megeJsonOutput();

            output.filename = state.PatchMod.ModKey.ToString(); // check to make sure this works to distinguish Synth vs. Standalone

            foreach (var plugin in state.LoadOrder)
            {
                output.loadOrder.Add(plugin.Key.FileName);
            }

            output.dateBuilt = DateTime.UtcNow.ToString("o", System.Globalization.CultureInfo.InvariantCulture);

            output.plugins = plugins;

            string writeDir = Path.Combine(settings.AssetOutputDirectory, "merge");
            if (Directory.Exists(writeDir) == false)
            {
                try
                {
                    Directory.CreateDirectory(writeDir);
                }
                catch
                {
                    throw new Exception("Could not create a directory for the output merge at " + writeDir);
                }
            }

            string writePath = Path.Combine(writeDir, "merge.json");

            try
            {
                File.WriteAllText(writePath, JsonConvert.SerializeObject(output, Formatting.Indented));
            }
            catch
            {
                throw new Exception("Could not write the merge.json to " + writePath);
            }
        }
    }
}
